{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"ArrayList通过源码分析扩容机制","date":"2021-03-23T02:35:55.817Z","updated":"2021-03-23T02:33:01.682Z","comments":true,"path":"2021/03/23/ArrayList通过源码分析扩容机制/","link":"","permalink":"http://example.com/2021/03/23/ArrayList%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/","excerpt":"","text":"ArrayList通过源码分析扩容机制ArrayList 是 java 集合框架中比较常用的数据结构了。继承自 AbstractList，实现了 List 接口。底层基于数组实现容量大小动态变化。允许 null 的存在。 成员变量12345678transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access &#x2F;** * The size of the ArrayList (the number of elements it contains). * * @serial *&#x2F; private int size; elementData：对象数组，用来存储集合中的元素 size：从源码的注解中也可看出，是集合的长度，是实际元素的个数 构造函数12345678&#x2F;** * Constructs an empty list with an initial capacity of ten. *&#x2F;public ArrayList() &#123; this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;; 源码注解的意思是构造一个初始容量为10的空集合。 实际上构造函数给 elementData 赋值了一个空的数组，在第一次添加元素时将容量扩大至 10 的。 操作方法add 1234567891011121314151617181920212223242526272829303132333435363738394041public boolean add(E e) &#123; ensureCapacityInternal(size + 1); &#x2F;&#x2F; Increments modCount!! elementData[size++] &#x3D; e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity &#x3D; Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; &#x2F;&#x2F; overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; &#x2F;** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity *&#x2F; private void grow(int minCapacity) &#123; &#x2F;&#x2F; overflow-conscious code int oldCapacity &#x3D; elementData.length; int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity &#x3D; minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity &#x3D; hugeCapacity(minCapacity); &#x2F;&#x2F; minCapacity is usually close to size, so this is a win: elementData &#x3D; Arrays.copyOf(elementData, newCapacity); &#125; 每次添加元素到集合中时都会先确认下集合容量大小。然后将 size 自增 1。 ensureCapacityInternal 函数中判断如果 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA 就取 DEFAULT_CAPACITY 和 minCapacity 的最大值也就是 10。 使用无惨构造函数时是在第一次添加元素时初始化容量为 10 的。ensureExplicitCapacity 中对 modCount 自增 1，记录操作次数， 然后如果 minCapacity 大于 elementData 的长度，则对集合进行扩容。第一次添加元素时 elementData 的长度为零。触发 grow 函数。 默认将扩容至原来容量的 1.5 倍。但是扩容之后也不一定适用，有可能太小，有可能太大。所以才会有下面两个 if 判断。如果1.5倍太小的话，则将我们所需的容量大小赋值给newCapacity，如果1.5倍太大或者我们需要的容量太大，那就直接拿 newCapacity = (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE 来扩容。然后将原数组中的数据复制到大小为 newCapacity 的新数组中，并将新数组赋值给 elementData。","categories":[],"tags":[]},{"title":"","slug":"自定义异常处理类校验接口入参","date":"2021-03-18T01:03:59.376Z","updated":"2021-03-18T01:20:52.210Z","comments":true,"path":"2021/03/18/自定义异常处理类校验接口入参/","link":"","permalink":"http://example.com/2021/03/18/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB%E6%A0%A1%E9%AA%8C%E6%8E%A5%E5%8F%A3%E5%85%A5%E5%8F%82/","excerpt":"","text":"自定义异常处理类校验接口入参一、问题：做沃易售的时候看到很多需要判断入参字段是否为空，为空的话就返回自定义提示！当判断入参很多的话用if判断的话代码就很繁琐。比如下面代码： 这只是3个，如果有10个的话代码量就很多了，虽然只需要cv。 二、解决方案：1、首先我们使用@Valid 和 @NotBlank 注解将入参交给spring校验代码如下： 入参对象字段注解： （message为入参校验不通过返回的提示信息） 方法入参注解： ​ 我们使用swagger测试一下： 从日志中可以发现，参数不符合校验规则会报MethodArgumentNotValidException异常。 2、使用自定义的异常处理类来捕捉异常并返回错误编码和提示信息 知道异常类型后，我们就来捕捉它 ​ 自定义异常处理类： @RestControllerAdvice：将被@RestControllerAdvice注解的类的内部所有被@ExceptionHandler, ​ @ InitBinderhe @ ModelAttribute注解的方法应用到所有被 @RequestMapping 注解的方法里面去。 ​ @ExceptionHandler 注解标明要捕捉的异常类型。 ​ BaseResp 为沃易售封装的返回报文格式，这个我们可以根据自己工程的报文格式来做。 我们将错误代码，及异常中自定义的message赋值并返回baseResp给前台。 ​ 再来一次！ ​ 按照指定的报文格式返回校验结果了！ 三、拓展：​ 1、不仅可以校验是否为空还可以这样 校验字段长度范围、校验数字大小！ 2、当然不止校验参数，我们还可处理其他异常并返回 在配置文件中设置上传文件最大为10M 异常处理类中新增 MaxUploadSizeExceededException异常捕捉的方法 测试一下，上传超过10M的文件返回报文 超过10M被拦截！","categories":[],"tags":[]},{"title":"","slug":"数据结构","date":"2021-03-16T08:43:02.463Z","updated":"2021-03-15T10:10:32.672Z","comments":true,"path":"2021/03/16/数据结构/","link":"","permalink":"http://example.com/2021/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"数据结构数据结构是计算机存储、组织数据的方式 线性结构列如：线性表(数组、链表、栈、队列、哈希表) 数组数组是一种顺序存储的线性表，所有元素的内存地址是连续的 树形结构二叉树、AVL树、红黑树、B树、堆、Trie、哈夫曼树、并查集","categories":[],"tags":[]}],"categories":[],"tags":[]}